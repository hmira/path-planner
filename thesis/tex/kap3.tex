\chapter{Nový algoritmus: NovellA*}

\section{Zlepšenie výkonu v niektorých prípadoch}
Nie všetky cesty sú ale také kľukaté. V mnohých prípadoch, napríklad keď medzi počiatočným a koncovým bodom neleží žiadna prekážka, 
sú cesty veľmi priamočiare. To sa pokúsime využiť na zlepšenie výkonu algoritmu v~niektorých prípadoch. 
Predstavme si, že máme obdlžníkovú mapu bez prekážoch a hľadáme najkratšiu cestu medzi bodmi $s=(x_s,y_s), t=(x_t,y_t)$.
V tomto prípade vieme nájsť najkratšiu cestu veľmi jednoducho.
Algoritmus:
vstup: \\
$s=(x_s,y_s), t=(x_t,y_t)$ \\
vystup:\\
path \dots usporiadaná množina súradníc po ktorých vedie cesta\\
beh algoritmu:\\


\lstset{language=Python}          
\begin{lstlisting} %[frame=single]  

path = (xs, ys)

TODO?? nejde diakritika??
# skopirujem suradnice pociatocneho vrcholu 
(x1, y1) = (xs, ys) 
while (x1, y1) <> (x2, y2):
	if y1 < y2:
		++y1
	else:
		--y1

	if x1 < x2:
		++x1
	else:
		--x1
	path.append((x1,y1))
\end{lstlisting}

Teda, jednoducho povedané: keď sa počiatočný a koncový bod líšia v jednej súradnici, tak sa posúvame priamočiaro,
keď sa líšia v oboch, tak sa posúvame šikmo.


Pokiaľ si zadefinujeme 
$ dx := |x_t - x_s|$ 
a
$ dy :=|y_t - y_s| $
 , tak počet vrcholov,
ktorými cesta prechádza vieme zhora odhadnúť, ako $\max(dx, dy)$. Jej vzdialenosť vieme zistiť v čase  $\BigO{\max(dx, dy)}$
Na zistenie vzdialenosti v každom kroku nám stači konštantná pamäť.

TODO?? Poznamka, ze nepotrebujem na to obdlzniky, mozem robit aj komplikovanejsie utvary, ale by to sa blbo hladalo... ledaze...

Skúsme to teda nejak využiť. Pokiaľ vieme, že počiatočný aj koncový bod ležia v jednom obdĺžniku, tak máme problém vyriešený. 
Jediným problémom ostalo takéto obdĺžniky nájsť. 


ASK?? alebo radsej neutralne napiast, hladanie obdlznikov?
\section{Hľadáme obdĺžniky}

Pre ľahšie vyjadrovanie si zaveďme definíciu {\sl čistej mriežkovej mapy}. Intuitívne ju môžme vnímať ako mriežkovú
mapu bez prekážok.

\begin{define}
{\sl Mriežková podmapa je čistá} 
pokiaľ medzi každými dvoma susednými vrcholmi existuje hrana.
\end{define}

\subsection{Proporcie obdĺžnikov}
Dôležitou otázkou je, aké proporcie obdĺžnikov hľadáme.
Predstavme si tieto dva prípady. Nech sme mapu dekomponovali na dva obdĺžniky, ktorých celkový obsah je 10.
V prvom prípade je obsah prvého 9 a druhého 1, v druhom prípade sú obsahy 6 a 4. 
Chceme maximalizovať pravdepodobnosť toho, že pri voľbe dvoch náhodných bodov budú obe v rovnakom obdĺžniku.

Úlohu vieme zobecniť na klasickú pravdepodobnostno-optimalizačnú úlohu.
Majme k ekvivalenčných tried na množine s n prvkami. Ako zvoliť ekvivalenčné triedy, aby pri voľbe dvoch náhodných prvkov 
bola pravdepodobnosť toho, že oba prvky budú v tej istej ekvivalenčnej triede čo najvyššia?
(Poznámka: ekvivalenčnú triedu predstavuje obdĺžnik a množinu predstavuje množina vrcholov grafu.)
Alternatívny pohľad poskytuje pozerať sa na úlohu, ako na farbenie guličiek čo najmenej farbami.

Zapíšme túto úlohu formálne.
Množinu prvkov nazvime $Prv$, označme ekvivalenčné triedy $ek_1 \dots ek_k$, množinu týchto ekvivalenčných tried označme ako $Ek$, veľkost 
triedy $ek_i$ označme $k_i$ a zaveďme si funkciu $f \colon Prv \to Ek$ ktorá roztriedi prvky do ekvivalenčných tried.

Označme výberový priestor $\Omega = \{(x_a, x_b) | x_a, x_b \in Prv, a \not= b \}$
Udalosťou $A_i$ nazveme jav, v~ktorom oba prvky patria do tej istej ekvivalenčnej triedy $i$,
teda $A_i = \{(x_a, x_b) | x_a, x_b \in Prv, a \not= b, f(x_a) = f(x_b) = i \}$
Jav $A = \bigcup_{i \in Ek} A_i$ teda nastáva práve vtedy,
 keď oba vybrané prvky patria do rovnakej triedy.

Úlohou je teda rozvrhnúť vytvoriť funkciu $f$ tak, aby pravdepodobnosť $P[A]$ bola čo najvyššia. 
Keďže udalosti $A_i$ sú nezlučiteľné, môžme písať 
$P[A] = P[\bigcup_{i \in Ek} A_i] = \sum_{i \in Ek}P[A_i]$.

Ak si pravdepodobnosť každého javu rozpíšeme, dostaneme 
$\sum_{i \in Ek}P[A_i] = \sum_{i = 1}^{|Ek|} \frac{{{k_i} \choose {2}}}{{{|Prv|} \choose {2}}}$.


nakoľko chceme nejak rozvrhnúť prvky v triedach $ek_i$, a menovateľ je len
konštanta, môžme ho vynechať.

Maximalizujeme teda hodnotu výrazu 
$\sum_{i = 1}^{|Ek|} {{k_i} \choose {2}} = \sum_{i = 1}^{|Ek|} {\frac{k_i!}{(k_i -2 )!2!}} = \sum_{i = 1}^{|Ek|}{\frac{k_i (k_i-1)}{2}}$.
Po vyškrtnutí konštanty a roznásobení sme dostali nasledujúcu optimalizačnú úlohu:
maximalizovať $\sum_{i = 1}^{|Ek|} {k_i^2 - k_i}$ za podmienok $\sum_{k=1}^{|Ek|}k_i = n$,
kde $k_i \in \N_0$.

Sumu si vieme rozpísať ako 
$\sum_{i = 1}^{|Ek|} {k_i^2 - k_i} = \sum_{i = 1}^{|Ek|} {k_i^2} + \sum_{i = 1}^{|Ek|}{-k_i}$
druhá suma sa nasčíta $-n$, čo je konštanta, takže nám stačí maximalizovať 
$\sum_{i = 1}^{|Ek|} {k_i^2}$.

