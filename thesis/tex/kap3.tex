\chapter{Nový algoritmus: NovellA*}

\section{Zlepšenie výkonu v niektorých prípadoch}
Nie všetky cesty sú ale také kľukaté. V mnohých prípadoch, napríklad keď medzi počiatočným a koncovým bodom neleží žiadna prekážka, 
sú cesty veľmi priamočiare. To sa pokúsime využiť na zlepšenie výkonu algoritmu v~niektorých prípadoch. 
Predstavme si, že máme obdlžníkovú mapu bez prekážoch a hľadáme najkratšiu cestu medzi bodmi $s=(x_s,y_s), t=(x_t,y_t)$.
V tomto prípade vieme nájsť najkratšiu cestu veľmi jednoducho.
Algoritmus:
vstup: \\
$s=(x_s,y_s), t=(x_t,y_t)$ \\
vystup:\\
path \dots usporiadaná množina súradníc po ktorých vedie cesta\\
beh algoritmu:\\


\lstset{language=Python}          
\begin{lstlisting} %[frame=single]  

path = (xs, ys)

TODO?? nejde diakritika??
# skopirujem suradnice pociatocneho vrcholu 
(x1, y1) = (xs, ys) 
while (x1, y1) <> (x2, y2):
	if y1 < y2:
		++y1
	else:
		--y1

	if x1 < x2:
		++x1
	else:
		--x1
	path.append((x1,y1))
\end{lstlisting}

Teda, jednoducho povedané: keď sa počiatočný a koncový bod líšia v jednej súradnici, tak sa posúvame priamočiaro,
keď sa líšia v oboch, tak sa posúvame šikmo.


Pokiaľ si zadefinujeme 
$ dx := |x_t - x_s|$ 
a
$ dy :=|y_t - y_s| $
 , tak počet vrcholov,
ktorými cesta prechádza vieme zhora odhadnúť, ako $\max(dx, dy)$. Jej vzdialenosť vieme zistiť v čase  $\BigO{\max(dx, dy)}$
Na zistenie vzdialenosti v každom kroku nám stači konštantná pamäť.

TODO?? Poznamka, ze nepotrebujem na to obdlzniky, mozem robit aj komplikovanejsie utvary, ale by to sa blbo hladalo... ledaze...

Skúsme to teda nejak využiť. Pokiaľ vieme, že počiatočný aj koncový bod ležia v jednom obdĺžniku, tak máme problém vyriešený. 
Jediným problémom ostalo takéto obdĺžniky nájsť. 


ASK?? alebo radsej neutralne napiast, hladanie obdlznikov?
\section{Hľadáme obdĺžniky}

Pre ľahšie vyjadrovanie si zaveďme definíciu {\sl čistej mriežkovej mapy}. Intuitívne ju môžme vnímať ako mriežkovú
mapu bez prekážok.

\begin{define}
{\sl Mriežková podmapa je čistá} 
pokiaľ medzi každými dvoma susednými vrcholmi existuje hrana.
\end{define}

\subsection{Proporcie obdĺžnikov}
Dôležitou otázkou je, na akých vlastnostiach obdĺžnikov záleží.
Majme na mape nájdené dva obdĺžniky, ktorých celkový obsah je 10.
Predstavme si tieto dva prípady. V prvom prípade je obsah prvého 9 a druhého 1, v druhom prípade sú obsahy 6 a 4. 
Chceme maximalizovať pravdepodobnosť toho, aby pri voľbe dvoch náhodných bodov boli obe v rovnakom obdĺžniku.

Úlohu vieme zobecniť na klasickú pravdepodobnostno-optimalizačnú úlohu.
Majme {\sl k} ekvivalenčných tried na množine s {\sl n} prvkami. Ako zvoliť ekvivalenčné triedy tak, 
aby pri voľbe dvoch náhodných prvkov bola pravdepodobnosť toho, 
že oba prvky budú v tej istej ekvivalenčnej triede čo najvyššia?
(Poznámka: ekvivalenčnú triedu predstavuje obdĺžnik a množinu predstavuje množina vrcholov grafu.)
Alternatívne sa môžeme na úlohu pozerať ako na problém farbenia guličiek čo najmenším počtom farieb.

Zapíšme túto úlohu formálne.
Majme $n$-prvkovú množinu $Prv = \{x_1,\ldots,x_n\}$, $k$-prvkovú množinu ekvivalenčných tried $Ek = \{ek_1,\ldots, ek_k\}$, veľkosť 
triedy $\|ek_i\|$ označme $k_i$ a zaveďme funkciu $f \colon Prv \to Ek$ ktorá roztriedi prvky do ekvivalenčných tried.

Označme výberový priestor $\Omega = \{(x_a, x_b) | x_a, x_b \in Prv, a \not= b \}$
Udalosťou $A_i$ nazveme jav, v~ktorom oba prvky patria do tej istej ekvivalenčnej triedy $ek_i$,
teda $A_i = \{(x_a, x_b) | x_a, x_b \in Prv, a \not= b, f(x_a) = f(x_b) = ek_i \}$
Jav $A = \bigcup_{i=1}^{k} A_i$ teda nastáva práve vtedy,
 keď oba vybrané prvky patria do rovnakej triedy.

Úlohou je teda navrhnúť funkciu $f$ tak, aby pravdepodobnosť $P[A]$ bola čo najvyššia. 
Keďže udalosti $A_i$ sú nezlučiteľné, môžme písať 
$P[A] = P[\bigcup_{i \in Ek} A_i] = \sum_{i \in Ek}P[A_i]$.

Ak si pravdepodobnosť každého javu rozpíšeme, dostaneme 
$\sum_{i \in Ek}P[A_i] = \sum_{i = 1}^{k} \frac{{{k_i} \choose {2}}}{{{|Prv|} \choose {2}}}$.


nakoľko chceme nejak rozvrhnúť prvky v triedach $ek_i$, a menovateľ je len
konštanta, môžme ho vynechať.

Maximalizujeme teda hodnotu výrazu 
$\sum_{i = 1}^{k} {{k_i} \choose {2}} = \sum_{i = 1}^{k} {\frac{k_i!}{(k_i -2 )!2!}} = \sum_{i = 1}^{k}{\frac{k_i (k_i-1)}{2}}$.
Po vyškrtnutí konštanty a roznásobení sme dostali nasledujúcu optimalizačnú úlohu:
maximalizovať $\sum_{i = 1}^{k} {k_i^2 - k_i}$ za podmienok $\sum_{k=1}^{k}k_i = n$,
kde $k_i \in \N_0$.

Sumu si vieme rozpísať ako 
$\sum_{i = 1}^{k} {k_i^2 - k_i} = \sum_{i = 1}^{k} {k_i^2} + \sum_{i = 1}^{k}{-k_i}$
druhá suma sa nasčíta $-n$, čo je konštanta, takže nám stačí maximalizovať 
$\sum_{i = 1}^{k} {k_i^2}$.

Teraz nám už len zostáva použiť nerovnosť
$(a+b)^2 \geq a^2 + b^2$ ktorá platí pre $a,b \geq 0$, z ktorej jasne vyplýva, že potrebujeme spraviť ľubovoľné $k_i$ čo najväčšie.
Ekvivalenčné triedy musia teda byť čo najväčšie a problém sa transformuje na problém hľadania
obdĺžnikov s najväčším možným obsahom.
V programe tento problém rieši trieda Colorizator.


\subsection{Nájdenie najväčšej jednotkovej podmatice}
Ako sme si v úvode povedali, mriežkovú mapu vieme reprezentovať ako maticu a teda
problém môžeme ekvivalentne zapísať ako problém hľadania najväčšej jednotkovej podmatice.
Tento problém má riešenie v čase lineárnom od počtu vrcholov a teda nájdenie $k$ najväčších
jednotkových matíc trvá $\BigO{k*n}$, kde n je počet vrcholov matice.

Popis algoritmu: 
V prvom prechode maticou si u každého vrcholu zapamätáme počet jedničiek naľavo od neho, vratane daneho vrcholu. 
Tento prechod trvá lineárny čas.

V druhom prechode treba prejsť zaradom všetky stĺpce zľava doprava